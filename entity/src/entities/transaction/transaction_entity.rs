//! `SeaORM` Entity. Generated by sea-orm-codegen 0.10.2

use async_graphql::Enum;
use async_trait::async_trait;
use color_eyre::{eyre::eyre, Result};
use sea_orm::{entity::prelude::*, ActiveValue, ConnectionTrait};
use serde::{Deserialize, Serialize};

use crate::deadline;

use super::{
    auction_transaction::new_auction_transaction,
    keeper_deadline_transaction::new_keeper_deadline_transaction,
    rookie_draft_selection_transaction::new_rookie_draft_selection_transaction,
    trade_transaction::new_trade_transaction,
};

/// A Transaction is any action taken by a user or the system that can change the state of a league or its teams.
/// Note that we are only recording final actions here; Intermediary actions (auction bids, trade actions) that by themselves do not change a team, contract, or the league are not recorded as a transaction.
/// Based on recorded transactions only, it should be possible to re-create the state of a league, even if intermediary data (bids, comments, trade actions that aren't the final trade state) is lost.
#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]
#[sea_orm(table_name = "transaction")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i64,
    pub end_of_season_year: i16,
    /// Represents the different types of transactions that occur in a league.
    pub kind: TransactionKind,
    pub league_id: i64,
    /// Represents an auction.
    pub auction_id: Option<i64>,
    /// Represents the deadline to which this transaction is tied. The reason this is necessary is because transactions may "happen" immediately, but they aren't executed until the date & time of their associated deadline.
    pub deadline_id: i64,
    /// Represents the contract that is tied to a contract being dropped.
    pub dropped_contract_id: Option<i64>,
    /// Represents the contract that is tied to an IR move.
    pub ir_contract_id: Option<i64>,
    /// Represents the contract that is tied to an RD <--> RDI move.
    pub rdi_contract_id: Option<i64>,
    /// Represents the contract that is tied to a rookie development -> rookie activation.
    pub rookie_contract_activation_id: Option<i64>,
    /// Represents a rookie draft selection.
    pub rookie_draft_selection_id: Option<i64>,
    /// Represents a trade.
    pub trade_id: Option<i64>,
    pub created_at: DateTimeWithTimeZone,
    pub updated_at: DateTimeWithTimeZone,
}

impl Model {
    /// Get the transaction's related deadline model.
    pub async fn get_deadline<C>(&self, db: &C) -> Result<deadline::Model>
    where
        C: ConnectionTrait,
    {
        self.find_related(deadline::Entity)
            .one(db)
            .await?
            .ok_or_else(|| {
                eyre!(
                    "Could not find deadline associated with transaction ({})",
                    self.id
                )
            })
    }

    /// Creates a new Auction transaction. Also note that this only creates the model, and does not persist the transaction to the database.
    pub fn new_auction_transaction(
        deadline_model: &deadline::Model,
        auction_id: i64,
    ) -> ActiveModel {
        new_auction_transaction(deadline_model, auction_id)
    }

    /// Creates a new Keeper Deadline transaction (note that there should only be one per league per year). Also note that this only creates the model, and does not persist the transaction to the database.
    pub fn new_keeper_deadline_transaction(keeper_deadline_model: &deadline::Model) -> ActiveModel {
        new_keeper_deadline_transaction(keeper_deadline_model)
    }

    pub fn new_preseason_start_transaction(
        preseason_start_deadline_model: &deadline::Model,
    ) -> ActiveModel {
        ActiveModel {
            end_of_season_year: ActiveValue::Set(preseason_start_deadline_model.end_of_season_year),
            kind: ActiveValue::Set(TransactionKind::PreseasonStart),
            league_id: ActiveValue::Set(preseason_start_deadline_model.league_id),
            deadline_id: ActiveValue::Set(preseason_start_deadline_model.id),
            ..Default::default()
        }
    }

    pub fn new_rookie_draft_selection_transaction(
        deadline_model: &deadline::Model,
        rookie_draft_selection_id: i64,
    ) -> ActiveModel {
        new_rookie_draft_selection_transaction(deadline_model, rookie_draft_selection_id)
    }

    pub fn new_trade_transaction(deadline_model: &deadline::Model, trade_id: i64) -> ActiveModel {
        new_trade_transaction(deadline_model, trade_id)
    }
}

/// Represents the different types of transactions that occur in a league.
#[derive(
    Debug, Clone, Copy, Eq, PartialEq, Enum, EnumIter, DeriveActiveEnum, Serialize, Deserialize,
)]
#[sea_orm(rs_type = "String", db_type = "String(None)")]
pub enum TransactionKind {
    /// The transaction is a trade between two teams.
    #[sea_orm(string_value = "Trade")]
    Trade,
    /// The transaction is the result of a team winning a player auction.
    #[sea_orm(string_value = "AuctionDone")]
    AuctionDone,
    /// Pre-season start.
    #[sea_orm(string_value = "PreseasonStart")]
    PreseasonStart,
    /// Pre-season keepers set.
    #[sea_orm(string_value = "PreseasonKeeper")]
    PreseasonKeeper,
    /// A rookie player was selected during the rookie draft.
    #[sea_orm(string_value = "RookieDraftSelection")]
    RookieDraftSelection,
    /// A team has manually dropped a player contract.
    #[sea_orm(string_value = "TeamUpdateDropContract")]
    TeamUpdateDropContract,
    /// A team has moved a player contract to IR.
    #[sea_orm(string_value = "TeamUpdateToIr")]
    TeamUpdateToIr,
    /// A team has moved a player contract from IR.
    #[sea_orm(string_value = "TeamUpdateFromIr")]
    TeamUpdateFromIr,
    /// A team has moved an RD player contract to RDI.
    #[sea_orm(string_value = "TeamUpdateToRdi")]
    TeamUpdateToRdi,
    /// A team has moved an RDI player contract back to RD.
    #[sea_orm(string_value = "TeamUpdateFromRdi")]
    TeamUpdateFromRdi,
    /// A team has activated a rookie contract, converting them to a rookie extension.
    #[sea_orm(string_value = "RookieContractActivation")]
    RookieContractActivation,
    /// A team has made a configuration change (ownership/name change).
    #[sea_orm(string_value = "TeamUpdateConfigChange")]
    TeamUpdateConfigChange,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_one = "crate::auction::Entity")]
    Auction,
    #[sea_orm(
        belongs_to = "crate::deadline::Entity",
        from = "Column::DeadlineId",
        to = "crate::deadline::Column::Id",
        on_update = "Cascade",
        on_delete = "Cascade"
    )]
    Deadline,
    #[sea_orm(
        belongs_to = "crate::contract::Entity",
        from = "Column::DroppedContractId",
        to = "crate::contract::Column::Id",
        on_update = "Cascade",
        on_delete = "Cascade"
    )]
    DroppedContract,
    #[sea_orm(
        belongs_to = "crate::league::Entity",
        from = "Column::LeagueId",
        to = "crate::league::Column::Id",
        on_update = "Cascade",
        on_delete = "Cascade"
    )]
    League,
    #[sea_orm(has_one = "crate::rookie_draft_selection::Entity")]
    RookieDraftSelection,
    #[sea_orm(has_many = "crate::team_update::Entity")]
    TeamUpdate,
    #[sea_orm(has_one = "crate::trade::Entity")]
    Trade,
}

impl Related<crate::auction::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Auction.def()
    }
}

impl Related<crate::contract::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::DroppedContract.def()
    }
}

impl Related<crate::deadline::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Deadline.def()
    }
}

impl Related<crate::league::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::League.def()
    }
}

impl Related<crate::rookie_draft_selection::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::RookieDraftSelection.def()
    }
}

impl Related<crate::team_update::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::TeamUpdate.def()
    }
}

impl Related<crate::trade::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Trade.def()
    }
}

#[async_trait]
impl ActiveModelBehavior for ActiveModel {
    async fn before_save<C>(self, _db: &C, _is_insert: bool) -> Result<Self, DbErr>
    where
        C: ConnectionTrait,
    {
        validate_required_column_values_for_transaction_types(&self)?;

        Ok(self)
    }
}

fn validate_required_column_values_for_transaction_types(model: &ActiveModel) -> Result<(), DbErr> {
    match model.kind.as_ref() {
        TransactionKind::Trade => {
            if model.trade_id.is_not_set() {
                return Err(DbErr::Custom(format!(
                    "Transaction of type 'Trade' must have a trade_id. ({:#?})",
                    model
                )));
            }
        }
        TransactionKind::AuctionDone => {
            if model.auction_id.is_not_set() {
                return Err(DbErr::Custom(format!(
                    "Transaction of type 'AuctionDone' must have an auction_id. ({:#?})",
                    model
                )));
            }
        }
        TransactionKind::RookieDraftSelection => {
            if model.rookie_draft_selection_id.is_not_set() {
                return Err(DbErr::Custom(format!(
                    "Transaction of type 'RookieDraftSelection' must have a rookie_draft_selection_id. ({:#?})",
                    model
                )));
            }
        }
        TransactionKind::TeamUpdateDropContract => {
            if model.dropped_contract_id.is_not_set() {
                return Err(DbErr::Custom(format!(
                    "Transaction of type 'TeamUpdateDropContract' must have a dropped_contract_id. ({:#?})",
                    model
                )));
            }
        }
        TransactionKind::TeamUpdateToIr => {
            if model.ir_contract_id.is_not_set() {
                return Err(DbErr::Custom(format!(
                    "Transaction of type 'TeamUpdateToIr' must have a ir_contract_id. ({:#?})",
                    model
                )));
            }
        }
        TransactionKind::TeamUpdateFromIr => {
            if model.ir_contract_id.is_not_set() {
                return Err(DbErr::Custom(format!(
                    "Transaction of type 'TeamUpdateFromIr' must have a ir_contract_id. ({:#?})",
                    model
                )));
            }
        }
        TransactionKind::TeamUpdateToRdi => {
            if model.rdi_contract_id.is_not_set() {
                return Err(DbErr::Custom(format!(
                    "Transaction of type 'TeamUpdateToRdi' must have a rdi_contract_id. ({:#?})",
                    model
                )));
            }
        }
        TransactionKind::TeamUpdateFromRdi => {
            if model.rdi_contract_id.is_not_set() {
                return Err(DbErr::Custom(format!(
                    "Transaction of type 'TeamUpdateFromRdi' must have a rdi_contract_id. ({:#?})",
                    model
                )));
            }
        }
        TransactionKind::RookieContractActivation => {
            if model.rookie_contract_activation_id.is_not_set() {
                return Err(DbErr::Custom(format!(
                    "Transaction of type 'RookieContractActivation' must have a rookie_contract_activation_id. ({:#?})",
                    model
                )));
            }
        }
        TransactionKind::TeamUpdateConfigChange => (),
        TransactionKind::PreseasonKeeper => (),
        TransactionKind::PreseasonStart => (),
    }

    Ok(())
}
