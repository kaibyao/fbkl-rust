//! SeaORM Entity. Generated by sea-orm-codegen 0.9.2

use std::fmt::Debug;

use async_trait::async_trait;
use color_eyre::{eyre::eyre, Result};
use sea_orm::{entity::prelude::*, ConnectionTrait, TransactionTrait};
use serde::{Deserialize, Serialize};
use tracing::instrument;

use crate::{team, team_user};

#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel, Serialize, Deserialize)]
#[sea_orm(table_name = "auction_bid")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i64,
    pub bid_amount: i16,
    pub comment: Option<String>,
    pub auction_id: i64,
    pub team_user_id: i64,
    pub created_at: DateTimeWithTimeZone,
    pub updated_at: DateTimeWithTimeZone,
}

impl Model {
    // #[instrument]
    // pub async fn get_team_user<C>(&self, db: &C) -> Result<team_user::Model> where C: ConnectionTrait + TransactionTrait + Debug {
    //     let related_team_user_model = self.find_related(team_user::Entity).one(db).await?.ok_or_else(|| eyre!("Could not find team_user related to auction bid (id={}).", self.id))?;
    //     Ok(related_team_user_model)
    // }

    #[instrument]
    pub async fn get_team<C>(&self, db: &C) -> Result<team::Model>
    where
        C: ConnectionTrait + TransactionTrait + Debug,
    {
        let related_team_model = self
            .find_linked(AuctionBidToTeam)
            .one(db)
            .await?
            .ok_or_else(|| {
                eyre!(
                    "Could not find team related to auction bid (id={}).",
                    self.id
                )
            })?;
        Ok(related_team_model)
    }
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::auction::Entity",
        from = "Column::AuctionId",
        to = "super::auction::Column::Id",
        on_update = "Cascade",
        on_delete = "Cascade"
    )]
    Auction,
    #[sea_orm(
        belongs_to = "super::team_user::Entity",
        from = "Column::TeamUserId",
        to = "super::team_user::Column::Id",
        on_update = "Cascade",
        on_delete = "Cascade"
    )]
    TeamUser,
}

impl Related<super::auction::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Auction.def()
    }
}

impl Related<super::team_user::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::TeamUser.def()
    }
}

#[derive(Debug)]
pub struct AuctionBidToTeam;
impl Linked for AuctionBidToTeam {
    type FromEntity = Entity;
    type ToEntity = team::Entity;
    fn link(&self) -> Vec<RelationDef> {
        vec![Relation::TeamUser.def(), team_user::Relation::Team.def()]
    }
}

#[async_trait]
impl ActiveModelBehavior for ActiveModel {
    async fn before_save<C>(self, _db: &C, _insert: bool) -> Result<Self, DbErr>
    where
        C: ConnectionTrait,
    {
        validate_bid_amount_is_positive(&self)?;

        Ok(self)
    }
}

fn validate_bid_amount_is_positive(model: &ActiveModel) -> Result<(), DbErr> {
    if model.bid_amount.as_ref().is_negative() {
        Err(DbErr::Custom(format!(
            "Bid amount must be positive. Was: {} for auction: {}.",
            model.bid_amount.as_ref(),
            model.auction_id.as_ref()
        )))
    } else {
        Ok(())
    }
}
