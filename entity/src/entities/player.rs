//! SeaORM Entity. Generated by sea-orm-codegen 0.9.2

use std::fmt::Debug;

use async_graphql::Enum;
use color_eyre::{eyre::eyre, Result};
use sea_orm::{entity::prelude::*, ConnectionTrait};
use serde::{Deserialize, Serialize};
use tracing::instrument;

use crate::real_team;

/// Real-world data on the player. Data is taken from ESPN data if it exists, then NBA data if it does not.
#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel, Serialize, Deserialize)]
#[sea_orm(table_name = "player")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i64,
    /// Whether a Rookie Development contract for the player is eligible to be converted to an International contract.
    pub is_rdi_eligible: bool,
    pub name: String,
    pub photo_url: Option<String>,
    pub thumbnail_url: Option<String>,
    /// The id of the player in ESPN's player data.
    pub espn_id: Option<i32>,
    /// The id of the player in the NBA's player index.
    pub nba_id: Option<i32>,
    pub position_id: i32,
    pub status: PlayerStatus,
    pub current_real_team_id: i64,
    pub created_at: DateTimeWithTimeZone,
    pub updated_at: DateTimeWithTimeZone,
}

impl Model {
    #[instrument]
    pub async fn get_real_team<C>(&self, db: &C) -> Result<real_team::Model>
    where
        C: ConnectionTrait + Debug,
    {
        let real_team_model = self
            .find_related(real_team::Entity)
            .one(db)
            .await?
            .ok_or_else(|| eyre!("Could not find real team for player (id = {}).", self.id))?;
        Ok(real_team_model)
    }
}

/// Whether the player is currently in the NBA.
///
/// How do you determine whether a player should appear in the player search results?
/// * If they're an active NBA player (the NBA player data does not show that they have a final year played).
/// * The current ESPN player data contains that player.
/// * If they were added by a league user and were added to a roster for the current `end_of_season_year`.
#[derive(
    Debug,
    Default,
    Clone,
    Copy,
    Enum,
    Eq,
    PartialEq,
    EnumIter,
    DeriveActiveEnum,
    Serialize,
    Deserialize,
)]
#[sea_orm(rs_type = "String", db_type = "String(None)")]
pub enum PlayerStatus {
    /// Player has been flagged as non-rostered + played a final year in the NBA + doesn't exist in ESPN fantasy data.
    #[default]
    #[sea_orm(string_value = "Retired")]
    Retired,
    /// Player exists as an active player in either ESPN fantasy or the NBA's player data.
    #[sea_orm(string_value = "Active")]
    Active,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::contract::Entity")]
    Contract,
    #[sea_orm(has_many = "super::league_player::Entity")]
    LeaguePlayer,
    #[sea_orm(
        belongs_to = "super::position::Entity",
        from = "Column::PositionId",
        to = "super::position::Column::Id",
        on_update = "Cascade",
        on_delete = "NoAction"
    )]
    Position,
    #[sea_orm(
        belongs_to = "super::real_team::Entity",
        from = "Column::CurrentRealTeamId",
        to = "super::real_team::Column::Id",
        on_update = "Cascade",
        on_delete = "NoAction"
    )]
    RealTeam,
}

impl Related<super::contract::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Contract.def()
    }
}

impl Related<super::league_player::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::LeaguePlayer.def()
    }
}

impl Related<super::position::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Position.def()
    }
}

impl Related<super::real_team::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::RealTeam.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}
