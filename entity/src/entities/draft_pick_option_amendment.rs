//! `SeaORM` Entity. Generated by sea-orm-codegen 0.12.2

use std::collections::HashMap;

use async_graphql::Enum;
use async_trait::async_trait;
use once_cell::sync::Lazy;
use sea_orm::{entity::prelude::*, ActiveValue};
use serde::{Deserialize, Serialize};

/// A Draft Pick Option Amendment is an addition or change to the clause of a draft pick option. It can also be the removal of a draft pick option. They are first created in a trade proposal and become active when a trade is processed.
#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]
#[sea_orm(table_name = "draft_pick_option_amendment")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i64,
    pub draft_pick_option_id: i64,
    pub amended_clause: Option<String>,
    pub status: DraftPickOptionAmendmentStatus,
    pub amendment_type: DraftPickOptionAmendmentType,
    pub created_at: DateTimeWithTimeZone,
    pub updated_at: DateTimeWithTimeZone,
}

/// Because a draft pick option amendment first exists as a trade idea and is not yet solidified/applied to a draft pick option, the status field is used to describe this intermediary state.
#[derive(
    Debug,
    Default,
    Clone,
    Copy,
    Enum,
    Eq,
    Hash,
    PartialEq,
    EnumIter,
    DeriveActiveEnum,
    Serialize,
    Deserialize,
)]
#[sea_orm(rs_type = "i16", db_type = "Integer")]
pub enum DraftPickOptionAmendmentStatus {
    /// The default status. This means the option has been proposed in a trade, but the trade has not been accepted yet.
    #[default]
    #[sea_orm(num_value = 0)]
    Proposed,
    /// The trade that created this option has been accepted and this option currently applies to the referenced draft pick.
    #[sea_orm(num_value = 1)]
    Active,
    /// This draft pick option has been activated + used on the draft pick.
    #[sea_orm(num_value = 2)]
    Used,
    /// The trade did not go through and this amendment died.
    #[sea_orm(num_value = 3)]
    CancelledViaTradeRejection,
    /// Trade has been invalidated by another trade that was processed that involves the draft pick related to this option targeted by the amendment.
    #[sea_orm(num_value = 4)]
    InvalidatedByExternalTrade,
}

/// Represents the different types of amendments that can be applied to a Draft Pick Option.
#[derive(
    Debug,
    Default,
    Clone,
    Copy,
    Enum,
    Eq,
    PartialEq,
    EnumIter,
    DeriveActiveEnum,
    Serialize,
    Deserialize,
)]
#[sea_orm(rs_type = "i16", db_type = "Integer")]
pub enum DraftPickOptionAmendmentType {
    /// Cancel/nullify a draft pick option. This causes a draft pick option to no longer be applicable to its targeted draft picks.
    #[default]
    #[sea_orm(num_value = 0)]
    Cancellation,
    /// Amend the clause of a draft pick option. This changes the nature of the draft pick option's effects.
    #[sea_orm(num_value = 1)]
    ClauseAmendment,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::draft_pick_option::Entity",
        from = "Column::DraftPickOptionId",
        to = "super::draft_pick_option::Column::Id",
        on_update = "Cascade",
        on_delete = "Cascade"
    )]
    DraftPickOption,
    #[sea_orm(has_one = "super::trade_asset::Entity")]
    TradeAsset,
}

impl Related<super::draft_pick_option::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::DraftPickOption.def()
    }
}

impl Related<super::trade_asset::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::TradeAsset.def()
    }
}

#[async_trait]
impl ActiveModelBehavior for ActiveModel {
    async fn before_save<C>(self, db: &C, is_insert: bool) -> Result<Self, DbErr>
    where
        C: ConnectionTrait,
    {
        require_proposed_status_when_inserting(&self, is_insert)?;
        validate_clause_required(&self)?;
        validate_update_status(&self, db, is_insert).await?;

        Ok(self)
    }
}

fn require_proposed_status_when_inserting(
    model: &ActiveModel,
    is_insert: bool,
) -> Result<(), DbErr> {
    if !is_insert {
        return Ok(());
    }

    if model.status != ActiveValue::Set(DraftPickOptionAmendmentStatus::Proposed) {
        Err(DbErr::Custom(
            "A new draft pick option amendment must be in the `Proposed` status.".to_string(),
        ))
    } else {
        Ok(())
    }
}

fn validate_clause_required(model: &ActiveModel) -> Result<(), DbErr> {
    if ActiveValue::Set(DraftPickOptionAmendmentType::ClauseAmendment) != model.amendment_type {
        return Ok(());
    }

    match &model.amended_clause {
        ActiveValue::Set(maybe_clause_text) => match maybe_clause_text {
            Some(clause_text) => match clause_text.trim() {
                "" => Err(DbErr::Custom(
                    "A draft pick option amendment that amends an option’s clause must have actual text in its own clause.".to_string(),
                )),
                _ => Ok(())
            },
            None => Err(DbErr::Custom(
                "A draft pick option amendment that amends an option’s clause must have its own clause to apply.".to_string(),
            )),
        },
        ActiveValue::NotSet => Err(DbErr::Custom(
            "A draft pick option amendment that amends an option’s clause must have its own clause to apply.".to_string(),
        )),
        _ => Ok(())
    }
}

async fn validate_update_status<C>(
    model: &ActiveModel,
    db: &C,
    is_insert: bool,
) -> Result<(), DbErr>
where
    C: ConnectionTrait,
{
    if is_insert {
        // handled by require_proposed_status_when_inserting()
        return Ok(());
    }

    static VALID_BEFORE_AND_AFTER_STATUSES: Lazy<
        HashMap<&DraftPickOptionAmendmentStatus, Vec<&DraftPickOptionAmendmentStatus>>,
    > = Lazy::new(|| {
        [
            (
                &DraftPickOptionAmendmentStatus::Proposed,
                vec![
                    &DraftPickOptionAmendmentStatus::Active,
                    &DraftPickOptionAmendmentStatus::CancelledViaTradeRejection,
                ],
            ),
            (
                &DraftPickOptionAmendmentStatus::Active,
                vec![&DraftPickOptionAmendmentStatus::Used],
            ),
            (&DraftPickOptionAmendmentStatus::Used, vec![]),
            (
                &DraftPickOptionAmendmentStatus::CancelledViaTradeRejection,
                vec![],
            ),
        ]
        .into_iter()
        .collect()
    });

    let ActiveValue::Set(Value::BigInt(maybe_id)) = model.get(Column::Id) else {
        return Err(DbErr::Custom("Couldn't extract id value from draft pick option amendment ActiveModel".to_string()))
    };
    let id = maybe_id.ok_or_else(|| {
        DbErr::Custom("Non-inserted draft pick option amendment doesn't have an id?!".to_string())
    })?;

    let current_saved = Entity::find_by_id(id).one(db).await?.ok_or_else(|| {
        DbErr::Custom(format!(
            "Couldn't find currently-persisted model of non-inserted draft pick option amendment (id = {})",
            id
        ))
    })?;
    let current_status = current_saved.status;
    let ActiveValue::Set(new_status) = model.status else {
        return Err(DbErr::Custom(format!("Couldn't extract status value from draft pick option amendment ActiveModel (id = {})", id)))
    };

    let valid_new_statuses = VALID_BEFORE_AND_AFTER_STATUSES
        .get(&current_status)
        .unwrap_or_else(|| {
            panic!(
                "VALID_BEFORE_AND_AFTER_STATUSES should have a value for key: {:?}",
                current_status
            )
        });

    if valid_new_statuses.contains(&&new_status) {
        Ok(())
    } else {
        Err(DbErr::Custom(format!("Not allowed to update a draft pick option amendment whose previous status was {:?} and is now {:?}", current_status, new_status)))
    }
}
